- Algorithm: [LeetCode #110 Balanced Binary Tree 平衡二叉树](https://www.jianshu.com/p/816432236ace)
- Review: [list.sort() vs. sorted(list)](https://en.wikipedia.org/wiki/AVL_tree)
- Tip: [AVL树 AVL Tree-wiki](https://en.wikipedia.org/wiki/AVL_tree)
- Share: 我的关于996的思考

## Algorithm
[LeetCode #110 Balanced Binary Tree 平衡二叉树](https://www.jianshu.com/p/816432236ace)

## Review
[list.sort() vs. sorted(list)](http://t.cn/ESiYBTC)
经常使用 list排序, 以前只关心记住 sort(list)和 list.sorted(), 一个是返回排序好的列表, 另外一个是原地修改列表. 这篇文章主要是从效率的角度考虑, 我的理解和作者也很相似, 主要是从是否是 sorted()不知道返回列表的大小和新建列表的损耗的角度考虑.

## Tip
### AVL树
> __AVL树__ 是基于 __二叉搜索树__ 的树, 是最早被发明的自平衡高度的树
> 查找、插入和删除在平均和最坏情况下的时间复杂度都是`Olog(n)`
> 增加和删除元素的操作则可能需要借由一次或多次树旋转, 以实现树的重新平衡
> AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis

AVL树一共有 4种失去平衡的情况:
1. 单向右旋平衡处理LL：由于在\*a的左子树根节点的左子树上插入节点，\*a的平衡因子由1增至2，致使以\*a为根的子树失去平衡，则需进行一次右旋转操作；
2. 单向左旋平衡处理RR：由于在\*a的右子树根节点的右子树上插入节点，\*a的平衡因子由-1变为-2，致使以\*a为根的子树失去平衡，则需进行一次左旋转操作；
3. 双向旋转（先左后右）平衡处理LR：由于在\*a的左子树根节点的右子树上插入节点，\*a的平衡因子由1增至2，致使以\*a为根的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。
4. 双向旋转（先右后左）平衡处理RL：由于在\*a的右子树根节点的左子树上插入节点，\*a的平衡因子由-1变为-2，致使以\*a为根的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。

### [C++代码](https://github.com/airmelt/Util/tree/master/AVL)


## Share:
### 我的关于996的思考
首先, 我个人是及其不愿意996的. 总体上来说, 加班的根本原因在于领导者决策上的失误, 或者安排工作不合理. 现在的互联网行业更新迭代快, 有些需求可能还没有进行认真思考及调研便提出研发要求, 一个是工期上比较赶, 另外一个是重复或者冗余开发也大量存在. 前者导致代码质量不高, 后者导致代码重复率高, 都会使得程序员的工作量加大.
其次, 作为一个立志终身学习的程序员, 我认为工作之外的 8小时才能决定一个程序员真正的高度. 我本身是转行过来的程序员, 深知基础对一个程序员是否优秀有着极大的影响. 所以, 我在工作之余会拼命补上基础, 如果在 996的环境下是绝无精力和时间去完成的.
另外, 我觉得适当的加班是必要的. 比如说企业刚刚起步的时候, 需要及时抢占市场, 机会稍纵即逝. 只要有明确的目标, 同事合力是可以适当的进行加班的. 不少互联网公司在初创期也经历过这一阶段. 但是, 我认为互联网的公司一旦形成了自己的护城河, 其边际成本还是比较小的, 不需要依靠堆叠功能来吸引用户, 反而是稳定的客户才能给公司一直带来收益. 这个阶段的公司, 就不应当继续大量加班, 而是优化体验.
最后, 现在各种培训机构, 学校都会有大量初级程序员进入这个行业, 所以初级程序员可替代性变高, 性价比变低也是必然的.
欲速则不达, 仅凭时间延长是不可能获得良好的编码的. 我们要成长, 不能在乎眼前的小利, 而是沉淀自己, 好好学习, 提升自己的价值, 才能有话语权.
